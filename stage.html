<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Mekong Stage</title>
  <style>
    table {
      border: 1px dotted #ddd;
    }

    td, ul {
      border: 1px solid #ddd;
    }

    #body {
      padding: 5px;
      margin: 20px;
      border: 1px solid #aaa;
    }
  </style>
</head>
<body>

  <div id="body" contenteditable="true">
  </div>

<script src="build/mekong.js"></script>
<script>
  var Mekong = require('mekong').default;
  var mekong = new Mekong(document.getElementById('body'));

  mekong.useEntity('Root');
  mekong.useEntity('Table');
  mekong.useEntity('Paragraph');
  mekong.useEntity('List');
  mekong.useEntity({ Image: function(core) {} });

  // A List
  /*var list = mekong.entity('List', { tag: 'ol' });
  var item1 = list.addItem({ text: 'item 1' });

  var item1_1 = item1.addItem({ text: 'item 1.1' });
  var item2 = list.addItem({ text: 'item 2' });
  var item1_2 = item1.addItem({ text: 'item 1.2' });
  var item1_3 = item1.addItem({ text: 'item 1.3' });

  item1.update({ text: 'lol' });
  item1_3.remove();
  console.log(list.state)*/
  // A Table
  /*var table = mekong.entity('Table');
  var row1 = table.addRow();

  column1 = row1.addColumn('text 1', {}, [])
  column2 = row1.addColumn('text 2', {}, [])
  column3 = row1.addColumn('text 3', {}, [])

  column2.update({ text: 'lol' });
  column3.remove();*/

  // A paragraph
  var p1 = mekong.entity('Paragraph', { tag: 'p', attrs: {} });
  p1.setText('Hello world!')
  p1.setText('Yay!')
  //p1.setText('Lol!')
  //p1.setTag('blockquote')
  //p1.setMarkup('strong', 0, 2)
  mekong.undo()
  mekong.undo()

  //mekong.redo()
  //mekong.entities.undoManager.undo()

  //mekong.entities.undoManager.redo()
  //p1.setMarkup('strong', 0, 5)
  //p1.setMarkup('em', 0, 5)

  /*var p2 = mekong.entity('Paragraph');
  p2.setText('Another paragraph')
  p2.setMarkup('em', 1, 4)*/

  //mekong.entities.undo()
  //paragraph.setMarkup('em', 0, 5)
  //paragraph.setMarkup('u', 0, 5)
  //paragraph.undo();
  //paragraph.redo();

  //paragraph.update({ text: 'Hell yeah!' })
  //paragraph.redo();


  /*paragraph.update({ attrs: { id: 'saintp', class: ['parag', 'parag1'] } })
  paragraph.update({ text: 'Y', start: 0, end: 1 })
  paragraph.update({ tag: 'pre' })*/
  //paragraph.update({ markup: [ ['strong', 0, 5] ] })
  /*paragraph.update({ markup: [ ['em', 3, 9] ] })
  paragraph.update({ attrs: { class: 'paragz' } }) // атрибуты надо мерджить тож
  paragraph.update({ tag: 'blockquote' })*/

  //console.log(paragraph.history)
  //console.log(paragraph.undoManager.state);
  //paragraph.undo();
  //console.log(paragraph.undoManager.state);

  //paragraph.update({ text: 'Y', start: 0, end: 1 })
  //paragraph.redo();
  //paragraph.undo();
  //paragraph.remove()
  ////////////////////////////////////////////////////////
  /*


  // Grid
  let gridEntity = api.operate('Insert', 'Grid', {}, container).result;
  let gridColumn1 = api.operate('Insert', 'GridColumn', {}, gridEntity).result;
  let gridColumn2 = api.operate('Insert', 'GridColumn', {}, gridEntity).result;
  let gridColumn3 = api.operate('Insert', 'GridColumn', {}, gridEntity).result;

  let p1 = api.operate('Insert', 'Paragraph', { text: 'p 1', markup: [] }, gridColumn1).result;
  let p2 = api.operate('Insert', 'Paragraph', { text: 'p 2', markup: [] }, gridColumn2).result;
  let p3 = api.operate('Insert', 'Paragraph', { text: 'p 3', markup: [] }, gridColumn3).result;


  При том, что есть сейчас, мы не можем контролировать, сколько например колонок может принимать
  грид - мы можем вставить сколько угодно, что есть плохо. Это потому, что API возможно
  не очень подходит. Может делать так:

  let rootContainer = new RootContainer(document.getElementById('body'));

  grid.appendEntity(
    new GridColumn({})
  )

  if (rootContainer.canAppendEntity(grid) {
    rootContainer.appendEntity(grid)
  }

  // List
  let list = new List({ tag: 'ol' });
  let listItem1 = listEntity.appendEntity(new ListItem({ text: 'hello world1', markup: [] }));
  listItem1.appendEntity(new ListItem({ text: 'what a day', markup: [] }));

  let listItem3 = listEntity.appendEntity(new ListItem({ text: 'substance', markup: [] }));
  container.appendEntity(list);

  // ---
  entity.append(anotherEntity); // Insert if anotherEntity is new or transfer
  entity.replaceWith(anotherEntity); // Replace
  entity.delete(); // Delete
  entity.update({ markup: [] }); // Update
  let moveOperation = entity.moveAfter(anotherEntity); // Move

  moveOperation.rollback();

  Каждая такая команда должна возвращать Oparation, у которой есть метод rollback()
  и мы можем откатить операцию.

   */
</script>

</body>
</html>
